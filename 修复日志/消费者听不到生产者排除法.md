# 双工声音，消费者听不到生产者声音 - 排除法修复日志

## 问题描述
1. 生产者（CaptureProcess）可以听到消费者（ScreenStreamApp）的声音。
2. **核心问题**：消费者听不到生产者的声音。
3. **已确认**：
   - 消费者麦克风正常（因为生产者能听到）。
   - 生产者端可以采集音频（待验证日志）。
   - 之前的“无脑广播”方案被用户否决，改用基于房间的路由方案。
   - 消费者成功连接到 WebSocket 服务器（状态 `ConnectedState`），但**收不到任何音频数据**（无 `Rx audio_opus` 日志）。

---

## 尝试 1: 客户端过滤 (已废弃)
**方案**: 广播所有音频，客户端根据 `target_id` 过滤。
**结果**: 用户否决，认为浪费带宽且逻辑不严谨。

## 尝试 2: 静态变量修复 (2025-12-10)
**方案**: 将 `main_capture.cpp` 中的 `audioInput`, `opusEncoder` 等改为静态变量，防止析构重置。
**结果**: 失败。消费者仍听不到。

## 尝试 3: 服务端房间路由 & 全链路检查 (2025-12-10)
**方案**: 
1. 服务端 (`websocket_server_with_routing.cpp`) 实现基于 `Room` 的精准路由。
2. 修复 `main_capture.cpp` 中 `remoteAudioEnabled` 默认为 `false` 的问题。
3. 修复 `main_capture.cpp` 中 `audioTimer` 读取数据堆积的问题 (改为 while loop)。
4. 增强 `WebSocketReceiver` 和 `AudioPlayer` 的调试日志。
**结果**: 失败。日志显示消费者连接成功，但没有收到任何音频数据包。

## 尝试 4: 消费者端日志增强 (2025-12-10)
**方案**: 在 `WebSocketReceiver.cpp` 中增加对 `audio_opus` 消息接收的详细统计日志。
**结果**: 失败。消费者端日志确认连接了正确的 URL (`/subscribe/...`)，但 `Rx audio_opus` 计数为 0。

## 尝试 5: 根本原因定位 (2025-12-10)
**分析**:
既然消费者连接成功但收不到数据，问题只能在：
1. **生产者未发送**: `WebSocketSender` 没发数据，或者没采集到数据。
2. **服务端未转发**: 路由表没建立，或者生产者没推流到正确房间。
3. **协议不匹配**: 生产者没收到 `start_streaming` 指令。

## 尝试 6: 协议修复 (2025-12-10)
**发现**: `WebSocketSender.cpp` 忽略了 `start_streaming_request` 消息，导致服务器请求推流时生产者无反应。
**修改**: 添加对 `start_streaming_request` 的处理，收到后触发 `startStreaming()`。
**结果**: 失败。

## 尝试 7: 连接状态日志增强 (2025-12-10)
**方案**: 增强 `WebSocketReceiver` 的连接状态变化日志，确认是否频繁断连。
**结果**: 消费者连接稳定 (`ConnectedState`)，但仍无数据。

## 尝试 8: 信号时序竞争条件修复 (2025-12-10)
**发现**: `main_capture.cpp` 中 `WebSocketSender` 的连接可能在信号槽绑定之前完成，导致错过 `streamingStarted` 信号。
**修改**: 调整代码顺序，先绑定所有信号槽，最后再调用 `connectToServer`。
**结果**: 失败。

## 尝试 9: 强制更新服务器 & 增强客户端日志 (2025-12-10)
**状态**: 失败
**分析**: 
1. 客户端日志显示消费者成功连接到 `ws://.../subscribe/29496`，状态为 `ConnectedState`。
2. 连接保持了约20秒，但没有任何 `[Receiver] Rx audio_opus` 日志出现。
3. 这证实了消费者**根本没有收到音频数据**，问题出在数据传输链的上游（生产者未发送或服务器未转发）。
4. 由于用户确认服务器代码是"第一条答案的时候"更新的，可能存在版本不一致（缺少路由逻辑或协议不匹配）。

## 尝试 10: 服务器日志精简与全链路验证 (2025-12-10)
**状态**: **进行中**
**用户痛点**: 服务器日志过多，无法复制；消费者依然听不到。
**分析**:
1. 既然消费者收不到，必须验证**生产者是否发了**。
2. 如果生产者发了，必须验证**服务器是否转了**。
3. 用户反馈服务器日志太多，影响排查。
**修改内容**:
1. **服务器端**: `websocket_server_with_routing.cpp` 注释掉高频的鼠标位置和文本消息日志，仅保留连接、推流、订阅和错误日志。
2. **生产者端**: `main_capture.cpp` 增加麦克风数据采集日志 (`[Audio] Microphone captured bytes`)；`WebSocketSender.cpp` 增加 Opus 数据包发送日志 (`[WebSocketSender] Sent audio_opus message`)。
3. **构建验证**: 重新构建 CaptureProcess 和 ScreenStreamApp。

## 尝试 11: 开启服务器音频日志验证转发 (2025-12-10)
**状态**: **已完成** (日志确认服务器未收到音频)
**目标**: 验证服务器是否收到并转发了 `audio_opus` 数据包。
**结果**: 
- 服务器日志显示收到推流请求并发送了 `start_streaming`。
- 客户端日志显示连接成功，但**没有收到任何音频包** (`Rx audio_opus` 缺失)。
- 服务器日志**没有显示** "转发音频包..." ( implying producer didn't send or server didn't log)。
**结论**: 问题极有可能出在**生产者 (CaptureProcess)** 未能发送音频数据（可能麦克风初始化失败或静音）。需要查看生产者的详细日志。

## 尝试 12: 启用本地文件日志 (2025-12-10)
**状态**: **进行中**
**目标**: 强制将所有进程（包括 CaptureProcess）的日志写入本地文件，以便排查生产者为何不发送音频。
**修改**:
1. **公共组件**: 修改 `src/common/ConsoleLogger.cpp`，在输出到控制台的同时，将日志写入 `logs/process_<pid>.log` 文件。
2. **目的**: 解决 CaptureProcess 日志在主控台不可见的问题，从而获取关键的音频初始化和发送状态。
**验证方法**:
1. 用户运行程序并尝试通话。
2. 检查程序运行目录下的 `logs` 文件夹。
3. 查找 CaptureProcess 的日志文件，搜索 `[Audio]` 标签，查看是否报错 "Audio source not active" 或 "Opus encode failed"。
**下一步**: 
1. 用户更新服务器代码。
2. 用户更新客户端。
3. 检查服务器日志是否包含 "转发音频包"。
## 尝试 15: 强制测试音注入 (即使麦克风故障) (2025-12-10)
**状态**: **已完成**
**目标**: 确保即使麦克风因权限被拒或设备故障而无法启动，程序仍能注入测试音以验证网络链路。
**修改**:
1. **CaptureProcess**: 修改 `src/capture/main_capture.cpp`。
   - 移除 `audioSource` 非 Active 状态时的提前返回逻辑。
   - 允许在麦克风故障（Error/Stopped）时，代码继续执行到测试音注入逻辑。
   - 修复了之前引入的 `PermissionDeniedError` 编译错误（替换为 `OpenError`）。
2. **AudioPlayer**: 修改 `src/video_components/AudioPlayer.cpp`。
   - 增加 `QAudioSink` 状态检测，如果意外停止则尝试重启。
**结果**: 消费者日志终于出现变化！显示 `Buffer full, dropping data.`。这表明：
1. 数据链路已打通（生产者->服务器->消费者）。
2. 之前的静默问题已解决。
3. 现在的新问题是播放器不消费数据，导致积压。

## 尝试 16: 添加 readyRead 信号唤醒播放器 (2025-12-10)
**状态**: **已完成 (无效)**
**目标**: 解决消费者端 `Buffer full` 问题，让音频真正播放出来。
**修改**:
1. **AudioPlayer**: 修改 `src/video_components/AudioPlayer.cpp`。
   - 在 `RingAudioIODevice` 中添加 `triggerReadyRead()` 方法。
   - 在 `processAudioData` 写入数据后，调用 `triggerReadyRead()` 发射 `readyRead` 信号。
**原因**: Qt 的 `QAudioSink` 在 Pull 模式下，如果缓冲区读空（返回0），会进入 Idle 状态并等待 `readyRead` 信号。之前的代码从未发射此信号，导致 Sink 永久休眠，数据积压。
**结果**: 日志仍显示 `Buffer full, dropping data`。说明 `readyRead` 信号未能成功唤醒 Sink，或者 Sink 因其他原因（如线程死锁、格式不支持）而未能调用 `readData`。Pull 模式的复杂性导致难以调试。

## 尝试 17: 切换到 Push 模式 (2025-12-10)
**状态**: **成功** (用户确认听到电报音)
**目标**: 彻底解决音频播放器不消费数据的问题。
**修改**:
1. **AudioPlayer**: 重构 `src/video_components/AudioPlayer.cpp`，移除 Pull 模式，改为 Push 模式直接写入。
**结果**: 
1. 消费者成功听到了“电报声音”（测试音）。
2. 这证实了整个音频传输链路（采集->编码->网络->解码->播放）已全通。
3. 之前听不到声音的最后障碍确实是播放器的 Pull 模式问题。

## 尝试 18: 修复麦克风采集 (2025-12-10)
**状态**: **已完成**
**目标**: 解决麦克风无数据问题，让消费者听到生产者的真实声音（不仅仅是测试音）。
**修改**:
1. `main_capture.cpp`:
   - 增加启动日志：输出选中设备名称 `inDev.description()`。
   - 强制设置音量最大：`audioSource->setVolume(1.0)`。
   - 优化读取逻辑：允许在 `IdleState` 下尝试读取数据（修复因暂时无数据导致的死锁）。
   - 增加“硬重启”逻辑：如果连续 10 秒无数据，强制调用 `stop()` 和 `start()` 重启音频源。
**原因**: 用户能听到测试音说明链路已通，但听不到人声说明 `audioInput->readAll()` 返回空，导致程序自动注入测试音。原因可能是设备初始化后进入 Idle 状态被代码逻辑忽略，或设备需要重置。
**预期结果**: 
1. 麦克风数据被正确读取，不再触发测试音注入。
2. 消费者能听到真实的说话声。
