#include <QMediaPlayer>
#include <QAudioDeviceInfo>
#include <QAudioOutputSelectorControl>

// 创建一个媒体播放器对象
QMediaPlayer *player = new QMediaPlayer;

// 列出所有可用的音频设备
QList<QAudioDeviceInfo> devices = QAudioDeviceInfo::availableDevices(QAudio::AudioOutput);
for (const QAudioDeviceInfo &device : devices) {
            
      
    qDebug() << "Available device: " << device.deviceName();
}

// 假设用户选择了第一个设备
if (!devices.isEmpty()) {
            
      
    player->setAudioOutput(devices.first());
}

// 播放音乐或电影
player->setMedia(QUrl::fromLocalFile("/path/to/media/file"));
player->play();

#include <QMediaPlayer>
#include <QAudioDeviceInfo>
#include <QAudioOutputSelectorControl>

// 创建一个媒体播放器对象用于视频会议中的声音输出
QMediaPlayer *conferencePlayer = new QMediaPlayer;

// 列出所有可用的音频输出设备
QList<QAudioDeviceInfo> outputDevices = QAudioDeviceInfo::availableDevices(QAudio::AudioOutput);
for (const QAudioDeviceInfo &device : outputDevices) {
            
      
    qDebug() << "Available output device: " << device.deviceName();
}

// 用户选择内置扬声器、耳机或外接音响
// 假设选择了第二个设备
if (outputDevices.size() > 1) {
            
      
    conferencePlayer->setAudioOutput(outputDevices[1]);
}

// 播放声音（视频会议中的声音）
conferencePlayer->setMedia(QUrl::fromLocalFile("/path/to/conference/audio"));
conferencePlayer->play();
录音软件

#include <QAudioInput>
#include <QAudioDeviceInfo>
#include <QFile>

// 列出所有可用的音频输入设备
QList<QAudioDeviceInfo> inputDevices = QAudioDeviceInfo::availableDevices(QAudio::AudioInput);
for (const QAudioDeviceInfo &device : inputDevices) {
            
      
    qDebug() << "Available input device: " << device.deviceName();
}

// 假设用户选择了第一个麦克风
QAudioDeviceInfo selectedDevice = inputDevices.first();

// 配置音频格式
QAudioFormat format;
format.setSampleRate(44100);
format.setChannelCount(2);
format.setSampleSize(16);
format.setCodec("audio/pcm");
format.setByteOrder(QAudioFormat::LittleEndian);
format.setSampleType(QAudioFormat::SignedInt);

// 检查设备是否支持此格式
if (!selectedDevice.isFormatSupported(format)) {
            
      
    qWarning() << "Default format not supported, trying to use the nearest.";
    format = selectedDevice.nearestFormat(format);
}

// 创建一个音频输入对象
QAudioInput *audioInput = new QAudioInput(selectedDevice, format);

// 打开文件以保存录音数据
QFile outputFile("/path/to/output/file.wav");
outputFile.open(QIODevice::WriteOnly);

// 开始录音
audioInput->start(&outputFile);
在线教育平台

#include <QMediaPlayer>
#include <QAudioDeviceInfo>
#include <QAudioOutputSelectorControl>

// 创建一个媒体播放器对象用于在线教育中的声音输出
QMediaPlayer *educationPlayer = new QMediaPlayer;

// 列出所有可用的音频设备
QList<QAudioDeviceInfo> audioDevices = QAudioDeviceInfo::availableDevices(QAudio::AudioOutput);
for (const QAudioDeviceInfo &device : audioDevices) {
            
      
    qDebug() << "Available audio device: " << device.deviceName();
}

// 老师可以选择不同的音频设备方便授课
// 假设选择了第三个设备
if (audioDevices.size() > 2) {
            
      
    educationPlayer->setAudioOutput(audioDevices[2]);
}

// 播放授课内容
educationPlayer->setMedia(QUrl::fromLocalFile("/path/to/lecture/audio"));
educationPlayer->play();

算法原理解释
获取系统当前可用的音频输出设备列表。
提供给用户一个界面来选择他们想要的设备。
当用户选择一个新设备时，停止当前音频流并重设 QAudioOutput 的设备。
重新开始音频流以确保音频从新的设备输出。
实际应用代码示例实现
#include <QApplication>
#include <QComboBox>
#include <QMediaDevices>
#include <QAudioOutput>
#include <QPushButton>
#include <QVBoxLayout>
#include <QWidget>

class AudioDeviceSwitcher : public QWidget {
            
      
    Q_OBJECT

public:
    AudioDeviceSwitcher(QWidget* parent = nullptr) : QWidget(parent) {
            
      
        QVBoxLayout* layout = new QVBoxLayout(this);
        
        comboBox = new QComboBox(this);
        const auto devices = QMediaDevices::audioOutputs();
        for (const auto& device : devices) {
            
      
            comboBox->addItem(device.description(), QVariant::fromValue(device));
        }
        
        QPushButton* switchButton = new QPushButton("Switch Device", this);
        
        layout->addWidget(comboBox);
        layout->addWidget(switchButton);
        
        connect(switchButton, &QPushButton::clicked, this, &AudioDeviceSwitcher::switchAudioDevice);
    }

private slots:
    void switchAudioDevice() {
            
      
        auto selectedDevice = comboBox->currentData().value<QAudioDevice>();
        if (!selectedDevice.isNull()) {
            
      
            delete audioOutput; // Clean up previous audio output
            audioOutput = new QAudioOutput(selectedDevice, this);
            // Additional code to redirect audio stream to the new device...
        }
    }

private:
    QComboBox* comboBox;
    QAudioOutput* audioOutput = nullptr;
};

int main(int argc, char *argv[]) {
            
      
    QApplication a(argc, argv);
    AudioDeviceSwitcher w;
    w.show();
    return a.exec();
}

#include "moc_AudioDeviceSwitcher.cpp"