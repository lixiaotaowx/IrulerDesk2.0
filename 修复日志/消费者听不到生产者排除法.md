# 消费者听不到生产者声音 - 排除法修复日志，不要动不动就给我删除文件

## 尝试 1: 客户端过滤 (2025-12-10)
**状态**: **已放弃**
**目标**: 解决串音问题，尝试在客户端根据 target_id 过滤音频。
**结果**: 用户拒绝此方案，认为浪费带宽且逻辑错误，要求服务端路由。

## 尝试 2: 服务端路由 (2025-12-10)
**状态**: **已完成**
**目标**: 实现服务端基于房间的路由，避免跨房间广播。
**修改**: 修改 websocket_server_with_routing.cpp，增加 Room 类和路由逻辑。
**结果**: 已实现，但消费者仍听不到声音，且出现单向音频问题。

## 尝试 3: 静态变量作用域修复 (2025-12-10)
**状态**: **已完成**
**目标**: 解决音频对象在函数结束后被释放的问题。
**修改**: 将 main_capture.cpp 中的音频对象移至静态作用域。
**结果**: 依然无声。

## 尝试 4: 信号连接顺序调整 (2025-12-10)
**状态**: **已完成**
**目标**: 确保 WebSocket 连接前信号已连接，避免错过 streamingStarted。
**修改**: 调整 main_capture.cpp 中 connectToServer 的调用位置。
**结果**: 连接流程正常，但仍无音频数据传输。

## 尝试 5: 自动恢复逻辑 (2025-12-10)
**状态**: **已完成**
**目标**: 解决音频传输意外停止导致的卡死。
**修改**: 在 main_capture.cpp 中增加看门狗定时器，无数据时自动重启。
**结果**: 增加了系统鲁棒性，但未解决根本的静音问题。

## 尝试 6: 修复编译错误 (2025-12-10)
**状态**: **已完成**
**目标**: 修复 main_capture.cpp 中 startAudio/stopAudio 找不到标识符的 C3861 错误。
**修改**: 调整函数定义顺序。
**结果**: 编译通过。

## 尝试 7: 本地文件日志 (2025-12-10)
**状态**: **已完成**
**目标**: 捕获丢失的生产者日志，确认音频是否被采集。
**修改**: 实现 ConsoleLogger 本地文件记录功能。
**结果**: 成功捕获日志，发现 [Audio] Sent Opus frame 日志缺失，说明根本没有发送音频。

## 尝试 8: 权限错误修复 (2025-12-10)
**状态**: **已完成**
**目标**: 修复 QAudio::PermissionDeniedError 编译错误。
**修改**: 替换为 QAudio::OpenError 并完善错误处理。
**结果**: 编译通过。

## 尝试 9: 注入测试音 (2025-12-10)
**状态**: **已完成**
**目标**: 区分麦克风硬件问题与软件传输问题。
**修改**: 在麦克风读取不到数据时，手动注入正弦波音频数据。
**结果**: 编译失败 (缺少 cmath)。

## 尝试 10: 修复测试音编译 (2025-12-10)
**状态**: **已完成**
**目标**: 添加 cmath 头文件。
**结果**: 编译通过，但消费者仍未听到声音。

## 尝试 11: 服务端日志增强 (2025-12-10)
**状态**: **已完成**
**目标**: 确认服务端是否收到并转发音频包。
**修改**: 在 websocket_server_with_routing.cpp 中启用 audio_opus 转发日志。
**结果**: 服务端显示转发正常，问题定位在消费者端。

## 尝试 12: 减少服务端日志 (2025-12-10)
**状态**: **已完成**
**目标**: 避免日志刷屏影响分析。
**修改**: 注释掉高频的鼠标和文本消息日志。
**结果**: 日志可读性提高。

## 尝试 13: 权限检查 (2025-12-10)
**状态**: **已完成**
**目标**: 检查麦克风权限是否被系统拦截。
**修改**: 在 main_capture.cpp 中添加 QPermissions 检查和请求逻辑。
**结果**: 权限显示正常。

## 尝试 14: 强制测试音注入 (2025-12-10)
**状态**: **已完成**
**目标**: 即使有麦克风对象也强制注入测试音，排除静音帧问题。
**修改**: 移除 main_capture.cpp 中的早期返回逻辑。
**结果**: 消费者日志终于出现变化！

## 尝试 15: 分析 Buffer Full (2025-12-10)
**状态**: **已完成**
**目标**: 确认数据到达。
**结果**: 消费者日志显示 `Buffer full, dropping data.`。这表明：
1. 数据链路已打通（生产者->服务器->消费者）。
2. 之前的静默问题已解决。
3. 现在的新问题是播放器不消费数据，导致积压。

## 尝试 16: 添加 readyRead 信号唤醒播放器 (2025-12-10)
**状态**: **已完成 (无效)**
**目标**: 解决消费者端 `Buffer full` 问题，让音频真正播放出来。
**修改**:
1. **AudioPlayer**: 修改 `src/video_components/AudioPlayer.cpp`。
   - 在 `RingAudioIODevice` 中添加 `triggerReadyRead()` 方法。
   - 在 `processAudioData` 写入数据后，调用 `triggerReadyRead()` 发射 `readyRead` 信号。
**原因**: Qt 的 `QAudioSink` 在 Pull 模式下，如果缓冲区读空（返回0），会进入 Idle 状态并等待 `readyRead` 信号。之前的代码从未发射此信号，导致 Sink 永久休眠，数据积压。
**结果**: 日志仍显示 `Buffer full, dropping data`。说明 `readyRead` 信号未能成功唤醒 Sink，或者 Sink 因其他原因（如线程死锁、格式不支持）而未能调用 `readData`。Pull 模式的复杂性导致难以调试。

## 尝试 17: 切换到 Push 模式 (2025-12-10)
**状态**: **成功** (用户确认听到电报音)
**目标**: 彻底解决音频播放器不消费数据的问题。
**修改**:
1. **AudioPlayer**: 重构 `src/video_components/AudioPlayer.cpp`，移除 Pull 模式，改为 Push 模式直接写入。
**结果**: 
1. 消费者成功听到了“电报声音”（测试音）。
2. 这证实了整个音频传输链路（采集->编码->网络->解码->播放）已全通。
3. 之前听不到声音的最后障碍确实是播放器的 Pull 模式问题。

## 尝试 18: 修复麦克风采集 (2025-12-10)
**状态**: **已完成**
**目标**: 解决麦克风无数据问题，让消费者听到生产者的真实声音（不仅仅是测试音）。
**修改**:
1. `main_capture.cpp`:
   - 增加启动日志：输出选中设备名称 `inDev.description()`。
   - 强制设置音量最大：`audioSource->setVolume(1.0)`。
   - 优化读取逻辑：允许在 `IdleState` 下尝试读取数据（修复因暂时无数据导致的死锁）。
   - 增加“硬重启”逻辑：如果连续 10 秒无数据，强制调用 `stop()` 和 `start()` 重启音频源。
**原因**: 用户能听到测试音说明链路已通，但听不到人声说明 `audioInput->readAll()` 返回空，导致程序自动注入测试音。原因可能是设备初始化后进入 Idle 状态被代码逻辑忽略，或设备需要重置。
**预期结果**: 
1. 麦克风数据被正确读取，不再触发测试音注入。
2. 消费者能听到真实的说话声。

## 尝试 19: 降低音频延迟 (2025-12-10)
**状态**: **已完成**
**目标**: 解决用户反馈的 2-3 秒音频延迟问题。
**修改**:
1. **WebSocketReceiver**: 修改 `src/player/WebSocketReceiver.cpp`。
   - **降低预缓冲**: 将起播阈值从 10 帧 (200ms) 降至 4 帧 (80ms)，加快声音输出。
   - **增加积压丢弃**: 设定最大队列长度为 10 帧 (200ms)。一旦网络拥塞导致积压超过此值，立即丢弃旧帧以追赶实时进度。
   - **日志监控**: 添加 `Latency control: dropped X frames` 日志以监控追赶触发情况。
**原因**: 之前的实现没有限制接收队列的增长。如果网络抖动或初始突发数据较多，队列会无限增长，而播放器以固定速度消费，导致积累的延迟无法消除。
**预期结果**: 
1. 延迟显著降低（预期在 300ms 以内）。

## 尝试 20: 修复多人音频信号循环 (2025-12-10)
**状态**: **已完成**
**目标**: 解决当第三台电脑（消费者）加入时，音频变得断断续续的问题。
**修改**:
1. **Server**: 修改 `websocket_server_with_routing.cpp`。
   - **限制转发**: 修改 `viewer_audio_opus` 消息的处理逻辑，仅将其转发给 `publisher` (生产者)，不再广播给其他 `subscriber` (消费者)。
**原因**: 用户反馈“信号循环”，经查服务器代码发现消费者的音频确实被广播给了所有其他消费者。这会导致 N 个消费者产生 N*(N-1) 的额外音频流，极大地消耗带宽并可能导致音频包处理混乱（因为消费者端可能没有混音逻辑，只能处理一路音频）。
**预期结果**: 
1. 第三台电脑加入时，音频保持清晰流畅，不再断断续续。
2. 消费者之间的音频流被切断（符合目前单向/星型架构设计）。

## 尝试 20: 修复多人音频信号循环 (2025-12-10)
**状态**: **已完成 (已 revert)**
**目标**: 解决当第三台电脑（消费者）加入时，音频变得断断续续的问题。
**修改**: 
1. **Server**: 修改 `websocket_server_with_routing.cpp`，限制 `viewer_audio_opus` 仅转发给生产者。
**结果**: 用户反馈“那不行 那就没有房间开会的意义了”，即必须支持所有人听到所有人。因此 revert 了此修改。恢复了全员广播模式。

## 尝试 21: 优化多人音频混音算法 (2025-12-10)
**状态**: **已完成**
**目标**: 在保持全员广播（会议模式）的前提下，解决第三人加入导致的“断断续续”和“外星人声音”问题。
**分析**:
1. **过度 PLC (Packet Loss Concealment)**: 原有的混音逻辑对每个 Peer 都无条件调用 `opus_decode`。如果某个 Peer 暂时不说话（队列为空），解码器会持续运行 PLC 产生修补音频。当有多个 Peer 时，这些 PLC 噪音叠加，导致听感断断续续或失真。
2. **资源泄露**: 之前的代码没有清理离开的 Peer 的解码器，导致 Peer 列表无限增长，增加 CPU 负担。
**修改**:
1. **Client (WebSocketReceiver)**: 
   - 引入 **智能 PLC 机制**：如果 Peer 队列为空超过 100ms (5帧)，视为静音，停止解码和混音，不再产生 PLC 噪音。
   - 引入 **僵尸 Peer 清理**：如果 Peer 超过 30秒 无数据，自动销毁其解码器并清理资源。
   - 保持原有的延迟控制 (Max Queue 10) 以确保低延迟。
**预期**: 多人会议时，只有正在说话的人的声音会被混入，静默的人不会引入噪音，且掉线的人会被自动清理。
