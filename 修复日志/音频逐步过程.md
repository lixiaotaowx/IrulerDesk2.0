# 音频逐步过程

**目标**
- 保留现有 WebSocket 服务器与视频/瓦片通道不动，通过 WebRTC(libdatachannel) 承载音频流。
- 先用 `g:\c\2025\lunzi\IrulerDeskpro\src\audio\test.mp3` 作为音源测试；成功后再切换麦克风采集。

**整体架构**
- WebSocket：登录、房间路由、控制消息、信令交换（SDP/ICE）、现有视频/瓦片数据。
- WebRTC(libdatachannel)：仅音频 Track；在允许 UDP 的环境下获取抖动缓冲/丢包掩蔽。

**基于 TCP 的稳定音频方案（借鉴 ws-audio-api）**
- 参考路径：`g:\c\2025\lunzi\IrulerDeskpro\参考\ws-audio-api-master`。其核心是：固定帧时长（20ms）、统一采样率与声道、Opus 编码、接收端环形缓冲队列、按节拍推进播放、缓冲区空时填充静音或用 PLC 掩蔽。
- 在本项目中保持 WebSocket（TCP）传输，沿用现有 `audio_opus` 文本消息，增强接收端抖动缓冲，确保“不断断续续”。

**关键机制对照**
- 帧规格：统一 20ms 帧；示例采样率 16000 或 24000，单声道。
- 编码：Opus VOIP 模式，保持低延迟；发送端固定 `frame_samples = sample_rate/50`。
- 缓冲：接收端维护“写入（入队）→读取（按需填充播放）”的环形队列，目标缓冲深度如 60–120ms；根据到达情况自适应收敛。
- 调度：独立 20ms 定时器推进播放时间线；当队列空缺时调用 Opus PLC（`opus_decode(..., nullptr, 0, ...)`）。
- 序号与乱序：消息携带自增 `seq`，接收端按 `seq` 重排，避免乱序导致的抖动。

**在现有代码的落地位置**
- 发送端打包位置：`src/capture/main_capture.cpp:368` 附近（采集/转换与 20ms 帧形成），在 `audio_opus` JSON 中增加 `seq` 字段并保持现有 `timestamp`、`frame_samples`。
- 接收端处理位置：`src/player/WebSocketReceiver.cpp:392` 的 `audio_opus` 分支，入队缓存并在 `src/player/WebSocketReceiver.cpp:48` 的 20ms 定时器节拍中解码；空队列时执行 PLC。
- 播放链：`src/video_components/VideoDisplayWidget.cpp:1181` 写入 `QAudioSink` 的 IO；确保写入速率与 20ms 节拍匹配。

**参数与策略（从 ws-audio-api 迁移建议）**
- 采样率：优先 16000；如带宽允许可用 24000；双端统一。
- 帧时长：固定 20ms；计算 `frame_samples = sample_rate/50`。
- 初始缓冲深度：80ms（4 帧）作为启动预热；根据队列长度自适应到 60–120ms 区间。
- 自适应规则：
  - 队列经常空：提高目标深度（+20ms），上限 160ms；
  - 队列持续偏长：降低目标深度（-20ms），下限 60ms；
  - 超时旧帧（滞后 > 300ms）直接丢弃，保持实时性。
- 静音/掩蔽：当队列不足一帧时调用 Opus PLC；若解码失败则输出零填充静音。

**以 test.mp3 为发送端音源的流程**
- 解码器：在发送端用轻量 MP3 解码（`minimp3` 或 `dr_mp3`）得到 `int16` PCM 单声道；必要时重采样到目标采样率。
- 切帧：按 20ms 将 PCM 切分，逐帧用现有 Opus 编码器编码；维护自增 `seq`。
- 发送：沿用当前 `audio_opus` 文本消息结构，新增 `seq` 字段；数据仍用 Base64。
- 验证：观看端按 20ms 节拍稳定播放，不因网络抖动而断续。

**TODO（将 ws-audio-api 的思路融入本项目）**
- 发送端：在 `audio_opus` JSON 增加 `seq` 字段（自增、32 位循环）。
- 发送端：用 `test.mp3` 解码为 PCM，统一到单声道与目标采样率，按 20ms 编码并发送。
- 接收端：实现环形缓冲队列，目标初始深度 80ms，按到达情况在 60–160ms 动态调节。
- 接收端：按 `seq` 重排，乱序与重复丢弃；过旧帧丢弃以保证实时。
- 接收端：20ms 定时器推进播放时间线；队列空时执行 Opus PLC；解码异常回退静音。
- 接收端：与 `QAudioSink` 写入速率对齐；避免 IO 堵塞或过度写入。
- 验证：本地环路与局域网测试，记录队列深度、丢弃率、PLC 触发率；观察是否仍有“断续”。

**注意事项**
- TCP 的“队头阻塞”可能造成突发延迟，抖动缓冲只能缓解；实时性目标建议控制在 60–120ms。
- 双端参数必须一致（采样率、声道、帧时长），确保解码不会间歇失败。
- 与视频独立节拍运行，音频不受视频帧率影响；避免误把“最后帧数循环”当作音频问题。

**高延迟优先稳定策略（仅 TCP）**
- 目标：允许端到端延迟提升到 200–400ms（必要时上探至 600ms），换取“完全不间断”的连续播放。
- 预缓冲：启动时先累积 `prebuffer_ms=200ms`，再进入稳定播放；避免开头的“空队列”。
- 目标缓冲深度：`target_buffer_ms` 初始 300ms；根据队列占用动态调节到 `[min=120ms, max=600ms]` 区间。
- 调节规则（每 1s 评估一次）：
  - 空队列或频繁 PLC：`target_buffer_ms += 20ms`（上限 600ms）。
  - 队列长期超高（滞后明显）：`target_buffer_ms -= 20ms`（下限 120ms）。
  - 突发到达：保持播放节拍不变，只逐步下调目标深度，避免“追赶播放”导致断续。
- 丢弃策略：到达帧若相对播放时间滞后 > 1000ms，直接丢弃（老帧）；重复 `seq` 丢弃；乱序按 `seq` 重排。
- PLC 使用：在 20ms 节拍时队列不足一帧，调用 `opus_decode(..., nullptr, 0, ...)` 进行掩蔽；解码失败则输出静音帧。
- 播放调度：严格以 20ms 定时器推进时间线；不要因到达抖动而改变播放速率，保持恒定节拍。
- 写入音频设备：必要时调大 `QAudioSink` 缓冲大小（设备层缓冲），并在暂停状态下调用 `resume()` 保持设备工作（参考 `src/video_components/VideoDisplayWidget.cpp:1181`）。

**实施步骤清单（高延迟版）**
- 发送端：在 `audio_opus` JSON 增加 `seq` 字段（自增、32 位循环）；保持 `timestamp` 与 `frame_samples`。
- 发送端：`test.mp3` → 解码为 `int16` 单声道 PCM；重采样到统一采样率（如 16000）；按 20ms 切帧与编码；源端维持均匀 50fps 音频帧发送节拍（避免突发）。
- 接收端：实现 `JitterBuffer`（环形缓冲）与 `AudioClock`：
  - `JitterBuffer`：按 `seq` 入队、重排；维护占用，支持丢弃过旧与重复帧。
  - `AudioClock`：以 20ms 定时器推进；启动前 `prebuffer_ms=200ms`；运行中维持 `target_buffer_ms≈300ms` 并自适应。
  - 队列不足调用 PLC；异常则静音。
- 接收端：统计 `buffer_occupancy_ms`、`plc_ratio`、`stutter_count`；用于动态调参与验收。
- 播放链：与 `QAudioSink` 写入保持 20ms 粒度；遇到 `SuspendedState` 时 `resume()`，保证设备连续输出（`src/video_components/VideoDisplayWidget.cpp:1181`）。
- 验收：以 `test.mp3` 循环为源，在局域网/云端分别测试；保证无“断断续续”，哪怕延迟稳定在几百毫秒。

**验收标准**
- 连续性：`stutter_count=0`（播放过程中不出现明显“断续”），即使端到端延迟达到 300–500ms。
- 掩蔽比例：`plc_ratio < 20%`；若超过，提升 `target_buffer_ms` 上限或检查网络突发拥塞。
- 缓冲占用：`buffer_occupancy_ms` 随时间稳定在目标值 ±40ms 范围；突发情况下可短期超出但能收敛。
- 旧帧丢弃：过旧帧丢弃计数存在但不影响连续性与音质；不做“追赶播放”。

**当前现状（复盘）**
- 发布端通过文本消息推送 `audio_opus`，开启/关闭由观看端控制：`src/capture/main_capture.cpp:689`。
- 观看端以 20ms 节拍解码并播放：`src/player/WebSocketReceiver.cpp:48`，播放链路 `src/video_components/VideoDisplayWidget.cpp:1181`。
- 服务器房间路由与消息转发入口：`server腾讯云服不要尝试本地构建这是上传给云的/websocket_server_with_routing.cpp:326`。

**此次成功修复与日志位置（2025-11-16）**
- 背景与根因
  - 无声的根因是发送端 MP3 源为 `32000 Hz`，而 Opus 解码器不接受 32000 Hz；改为强制 16000 Hz 单声道 20ms 帧，统一双端参数。
  - 发送端使用 `QAudioDecoder` 解码 MP3，内存中重采样到 16k，并以固定节拍编码发送。
- 发送端改动摘要
  - 固定编码参数：`opusSampleRate=16000`、`opusFrameSize=320`，VOIP 模式、VBR、FEC 开启。
    - 位置：`src/capture/main_capture.cpp:720–734`
  - MP3 解码并重采样到 16k、形成 20ms 帧、发送 `audio_opus`（含 `seq/timestamp/frame_samples`）。
    - 位置：`src/capture/main_capture.cpp:736–832`
  - 诊断日志（std）：
    - 开关与编码器初始化：`src/capture/main_capture.cpp:717–734`
    - 解码器格式变化：`src/capture/main_capture.cpp:740–742`
    - 每个解码 buffer：`src/capture/main_capture.cpp:752`
    - 重采样输出帧数：`src/capture/main_capture.cpp:787`
    - 累积字节数与发送帧：`src/capture/main_capture.cpp:790–817`
    - 循环播放重启：`src/capture/main_capture.cpp:823–827`
- 接收端改动摘要
  - 预缓冲启动：队列累计到 10 帧（≈200ms）再启动 20ms 解码节拍，避免开头断续。
    - 音频入队与启动：`src/player/WebSocketReceiver.cpp:438–447`
  - 20ms 定时器节拍解码与 PLC 掩蔽（队列空调用 `opus_decode(..., nullptr, 0, ...)`）。
    - 位置：`src/player/WebSocketReceiver.cpp:46–86`
  - 诊断日志（std）：
    - 收到帧与队列长度：`src/player/WebSocketReceiver.cpp:442`
    - 预缓冲启动提示：`src/player/WebSocketReceiver.cpp:447`
    - PLC/正常解码样本数：`src/player/WebSocketReceiver.cpp:67`、`76`
- 播放链路与日志位置
  - 写入 `QAudioSink` 并在 `StoppedState/SuspendedState` 下 `start()/resume()`，保证设备工作。
    - 位置：`src/video_components/VideoDisplayWidget.cpp:1176–1185`
  - 诊断日志（std）：
    - 收到帧与写入字节数：`src/video_components/VideoDisplayWidget.cpp:1170`、`1185`
- 构建与日志转发
  - 主程序恢复转发子进程日志，方便观察 FFmpeg/QAudioDecoder 输出。
    - 位置：`src/MainWindow.cpp:449`（`QProcess::ForwardedChannels`）
- 验证结果
  - 观看端日志显示：
    - `[PlayerUI] audioFrameReceived sr=16000 ch=1 bytes=640`（20ms 一帧，320 样本 × 2 字节）
    - `[PlayerUI] wrote bytes=640`（成功写入音频设备）
    - `[Receiver] decoded samples=320`（解码输出 320 样本）
  - 表明链路已稳定工作、播放连续。
- 日志清理建议
  - 这些诊断日志每 20ms 输出一次，默认用于定位问题；不需要时直接移除对应行或改为每秒抽样打印。
  - 可移除行：
    - 发送端：`src/capture/main_capture.cpp:717–742, 752, 787, 790–817, 823–827`
    - 接收端：`src/player/WebSocketReceiver.cpp:67, 76, 442, 447`
    - 播放侧：`src/video_components/VideoDisplayWidget.cpp:1170, 1185`

**信令协议（JSON，走房间 WebSocket）**
- 订阅者→发布者：
  - `{"type":"webrtc_offer","viewer_id":"<v>","target_id":"<t>","sdp":"..."}`
  - `{"type":"ice_candidate","viewer_id":"<v>","target_id":"<t>","candidate":"...","mid":"audio","mline_index":0}`
- 发布者→订阅者：
  - `{"type":"webrtc_answer","viewer_id":"<v>","target_id":"<t>","sdp":"..."}`
  - `{"type":"ice_candidate","viewer_id":"<v>","target_id":"<t>","candidate":"...","mid":"audio","mline_index":0}`
- 服务器按房间与角色路由上述三类消息，模式参考鼠标消息转发：`server腾讯云服不要尝试本地构建这是上传给云的/websocket_server_with_routing.cpp:431`。

**阶段 A：仅音频接入 WebRTC**
- 发送端（发布者，RtcAudioSender）：
  - 初始化 `rtc::PeerConnection`（含 STUN `stun.l.google.com:19302`；需要 TURN 时补充）。
  - 建立音频源：先解码 `test.mp3` 为 `int16` 单声道 PCM，20ms 帧（推荐 `minimp3`/`dr_mp3` 作为轻量解码器）。
  - 将帧以 20ms 间隔送入音频 Track；生成 `answer` 与本地 ICE 通过 WebSocket 发送。
  - 收到订阅者的 `offer` 与对端 ICE，设置远端描述与候选。
- 接收端（订阅者，RtcAudioReceiver）：
  - 创建 `rtc::PeerConnection`，发起 `offer`，收 `answer` 与对端 ICE。
  - 在 `onTrack` 获取音频 Track 回调，桥接到 GUI 播放链路：发射 `audioFrameReceived(pcm, sampleRate, channels, bits, timestamp)` → `QAudioSink` 播放（与现有接口一致，文件：`src/video_components/VideoDisplayWidget.cpp:1181`）。
- 切换逻辑：
  - RTC 音频建立成功后，由观看端发送 `sendAudioToggle(false)` 关闭旧文本音频（参考 `src/player/WebSocketReceiver.h:72` 与 `src/player/WebSocketReceiver.cpp:423`）。

**阶段 A.5：切换到麦克风**
- 将 `RtcAudioSender` 的音源替换为 `QAudioSource`（采样格式与当前转换保持一致）：`src/capture/main_capture.cpp:368` 的 20ms 帧、单声道 `int16` 转换逻辑可复用。
- 保持时间戳推进与缓冲一致性，避免与视频渲染节拍冲突。

**阶段 B：多订阅者**
- 每个订阅者维护独立 `PeerConnection`；服务器在信令消息中按 `viewer_id` 精确路由。
- 房间内订阅者管理沿用现有结构；统计输出沿用服务器监控：`server腾讯云服不要尝试本地构建这是上传给云的/websocket_server_with_routing.cpp:529`。

**阶段 C（可选）：视频迁移到 WebRTC**
- 保持先音频、后视频的节奏；视频迁移需要带宽与编解码策略评估，暂不展开。

**服务器改动点**
- 在房间消息分支增加：
  - `webrtc_offer`：订阅者→发布者。
  - `webrtc_answer`：发布者→订阅者。
  - `ice_candidate`：按 `role` 双向转发。
- 复用观看请求与 `viewer_id`/`target_id` 的寄存模式：`server腾讯云服不要尝试本地构建这是上传给云的/websocket_server_with_routing.cpp:283`。

**测试验证流程**
- 本地环路（单机）：
  - 发布端与订阅端都连同一房间；订阅端发 `offer` → 发布端回 `answer` → ICE 完成。
  - 用 `test.mp3` 推 20ms 帧，确认 GUI 正常播放。
- 局域网（两机）：
  - 启用 STUN；必要时配置 TURN。检查 UDP 与防火墙策略。
- 云端：
  - 登录系统与房间路由保持；成功建连后立刻关闭旧文本音频。
- 验证点：
  - 音频连续性与端到端时延；丢包掩蔽效果。
  - CPU/带宽占用对比旧方案；多订阅者并发稳定性。

**分阶段 TODO 清单**
- 在服务器房间分支新增三类信令消息路由（offer/answer/ice）。
- 发布端实现 `RtcAudioSender`（PeerConnection + 音频 Track）。
- 订阅端实现 `RtcAudioReceiver`（发起 offer + onTrack 输出到播放链）。
- 接入 `test.mp3`，解码为 20ms 单声道 `int16` PCM 并推送。
- RTC 音频建立成功后下发 `audio_toggle:false`，停用旧 `audio_opus` 文本音频。
- 由 `QAudioSource` 接替 `test.mp3`，完成麦克风采集切换。
- 环路/局域网/云端逐级验证并记录统计。

**风险与备用方案**
- NAT/防火墙导致 ICE 失败：准备 TURN（带鉴权）。
- 音频格式不一致：统一为 16k/48k 单声道 `int16`，保持 20ms 帧。
- 与视频节拍耦合：音频独立 20ms 节拍，不依赖视频帧率；避免“最后帧数再循环”的误判。

**代码参考（定位）**
- 发布端：`src/capture/main_capture.cpp:368`（采集与 20ms 转换）、`src/capture/WebSocketSender.cpp:265`（推流启动）。
- 观看端：`src/player/WebSocketReceiver.cpp:48`（20ms 解码节拍）、`src/video_components/VideoDisplayWidget.cpp:1181`（播放）。
- 服务器：`server腾讯云服不要尝试本地构建这是上传给云的/websocket_server_with_routing.cpp:283, 326, 431, 529`。